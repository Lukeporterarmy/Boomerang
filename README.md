# Project Boomerang

## License is located at the top of the directory.

Why do you want this software? Money. Imagine an employee that manages themselves. There is no need to pay a manager anymore. This is essentially what will be happening and why money will be saved on IT infrastructure. This is something that will be completely unique to each company. These concepts also use theories not commonly practiced without closed source licensing software to accomplish similiar but unrelated tasks. It gives you complete control to customer software with piece of mind that sources are not referenced in deployment of software. Software locks are a safe way to access applications remotely without a constant connection being established. From a security standpoint, there is less network interaction in general, leading to less of a footprint overall. This makes this combination of industry techniques an interesting viable cost saving feature. The best way to explain exactly how this software works in one sentence is to think of this like an actual boomerang. You can throw the software boomerang out into the abyss and it will eventually come back but it is not connected anymore to where it was thrown until it is returned sequentially to the thrower. You could say it might be like a fishing pole, but that would imply there are strings connecting the tool. A magnetic object that when introduced to a magnet will react.

This software also has uses for law enforcement.

This is a proof of concept, however, the project can be adapted for customers and customized so that it can have a wide range of adaptability.

This is a network authenticated, software locking, server to client relationship. This particular project is an installer. This involves use of asynchronous encryption, round robin encryption, network authentication, software dependency change, software locking, and boomeranging software.

As an installer this project links between the unknown and known by the client application. The client starts out dependant on the installer, then the client gains control of itself analytically but it is left with remnants from the installer. The installer has a neat trick to recapture the client using a locking feature and some various techniques. The analytical dependency will be implemented in production, with dependency being introduced locally as code or over the network in the form of an IP address as another example. In this proof of concept, the program will unlock and create files that will introduce the code locally, which in this case is code that will have a reference to the new dependency.

The software lock reintroduces an original dependency where the installer can then regain control of the client as just another example.


First the installer application generates all the code needed for the client application to interact with the installer. With each decryption, comes another opportunity for the client application to decrypt itself. The installer knows everything about the client by design. The installer has sent and also sends data for the client to decrypt various parts of itself, to help it discover itself. As the client discovers itself, the installer is also continually notified of that clients progression in production. 

The client holds something it knows nothing about. 

The client information is intended to be given to the authentication server for it to interpret. With this shared interpretation, the authentication server will also rely on something from the installer, establishing a link between all three entities.

With all three of these relationships continually verifying each other, eventually after all the functions of the installer, client, and authentication server are executed together leading to a final unlocking of the client. The program will then change itself with enough supporting evidence to make an improbable prediction to something believable. The final determination being made from the client with information from the authentication server.

